{
    "componentChunkName": "component---src-layouts-entry-page-layout-tsx",
    "path": "/entry/2019/darknet_python_opencv/",
    "result": {"data":{"mdx":{"id":"ac0e6395-e983-5d79-9575-97cba95efbb9","slug":"2019/darknet_python_opencv/","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"darknet.py OpenCV\",\n  \"date\": \"2019-10-30 14:03:48\",\n  \"draft\": false,\n  \"channel\": \"技術ノート\",\n  \"category\": \"Python\",\n  \"tags\": [\"Python\", \"機械学習\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"darknetpy-opencv\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#darknetpy-opencv\",\n    \"aria-label\": \"darknetpy opencv permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"darknet.py OpenCV\"), mdx(\"p\", null, \"darknet.py\\u306B\\u30B3\\u30FC\\u30C9\\u304C\\u53E4\\u304F\\u306A\\u3063\\u3066\\u308B\\u3063\\u307D\\u3044\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"examples/detector-scipy-opencv.py\"), \"\\u306EOpenCV\\u90E8\\u3092\\u53D6\\u308A\\u8FBC\\u307F\\u3001Python 3\\u7528\\u306B\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"import cv2\\n\\nimport sys, os\\nsys.path.append(os.path.join(os.getcwd(),'python/'))\\n\\nimport darknet as dn\\n\\nnet = dn.load_net(\\\"cfg/yolov3.cfg\\\", \\\"backup/hoge.weights\\\", 0)\\nmeta = dn.load_meta('cfg/yolov3.cfg')\\n\\nnp_image = cv2.imread('data/dog.jpg')\\nr = dn.detect_cv(net, meta, np_image)\\n\\nprint(r)\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from ctypes import *\\nimport math\\nimport random\\n\\nimport os\\n\\nDARKNET_SO_PATH = os.environ.get('DARKNET_SO_PATH', os.path.realpath('./libdarknet.so'))\\n# assert os.path.exists(DARKNET_SO_PATH), DARKNET_SO_PATH\\n\\n\\ndef sample(probs):\\n    s = sum(probs)\\n    probs = [a/s for a in probs]\\n    r = random.uniform(0, 1)\\n    for i in range(len(probs)):\\n        r = r - probs[i]\\n        if r <= 0:\\n            return i\\n    return len(probs)-1\\n\\ndef c_array(ctype, values):\\n    arr = (ctype*len(values))()\\n    arr[:] = values\\n    return arr\\n\\nclass BOX(Structure):\\n    _fields_ = [(\\\"x\\\", c_float),\\n                (\\\"y\\\", c_float),\\n                (\\\"w\\\", c_float),\\n                (\\\"h\\\", c_float)]\\n\\nclass DETECTION(Structure):\\n    _fields_ = [(\\\"bbox\\\", BOX),\\n                (\\\"classes\\\", c_int),\\n                (\\\"prob\\\", POINTER(c_float)),\\n                (\\\"mask\\\", POINTER(c_float)),\\n                (\\\"objectness\\\", c_float),\\n                (\\\"sort_class\\\", c_int)]\\n\\n\\nclass IMAGE(Structure):\\n    _fields_ = [(\\\"w\\\", c_int),\\n                (\\\"h\\\", c_int),\\n                (\\\"c\\\", c_int),\\n                (\\\"data\\\", POINTER(c_float))]\\n\\nclass METADATA(Structure):\\n    _fields_ = [(\\\"classes\\\", c_int),\\n                (\\\"names\\\", POINTER(c_char_p))]\\n\\n\\n\\n#lib = CDLL(\\\"/home/pjreddie/documents/darknet/libdarknet.so\\\", RTLD_GLOBAL)\\n# lib = CDLL(\\\"libdarknet.so\\\", RTLD_GLOBAL)\\nlib = CDLL(DARKNET_SO_PATH, RTLD_GLOBAL)\\nlib.network_width.argtypes = [c_void_p]\\nlib.network_width.restype = c_int\\nlib.network_height.argtypes = [c_void_p]\\nlib.network_height.restype = c_int\\n\\npredict = lib.network_predict\\npredict.argtypes = [c_void_p, POINTER(c_float)]\\npredict.restype = POINTER(c_float)\\n\\nset_gpu = lib.cuda_set_device\\nset_gpu.argtypes = [c_int]\\n\\nmake_image = lib.make_image\\nmake_image.argtypes = [c_int, c_int, c_int]\\nmake_image.restype = IMAGE\\n\\nget_network_boxes = lib.get_network_boxes\\nget_network_boxes.argtypes = [c_void_p, c_int, c_int, c_float, c_float, POINTER(c_int), c_int, POINTER(c_int)]\\nget_network_boxes.restype = POINTER(DETECTION)\\n\\nmake_network_boxes = lib.make_network_boxes\\nmake_network_boxes.argtypes = [c_void_p]\\nmake_network_boxes.restype = POINTER(DETECTION)\\n\\nfree_detections = lib.free_detections\\nfree_detections.argtypes = [POINTER(DETECTION), c_int]\\n\\nfree_ptrs = lib.free_ptrs\\nfree_ptrs.argtypes = [POINTER(c_void_p), c_int]\\n\\nnetwork_predict = lib.network_predict\\nnetwork_predict.argtypes = [c_void_p, POINTER(c_float)]\\n\\nreset_rnn = lib.reset_rnn\\nreset_rnn.argtypes = [c_void_p]\\n\\n_load_net = lib.load_network\\n_load_net.argtypes = [c_char_p, c_char_p, c_int]\\n_load_net.restype = c_void_p\\n\\ndo_nms_obj = lib.do_nms_obj\\ndo_nms_obj.argtypes = [POINTER(DETECTION), c_int, c_int, c_float]\\n\\ndo_nms_sort = lib.do_nms_sort\\ndo_nms_sort.argtypes = [POINTER(DETECTION), c_int, c_int, c_float]\\n\\nfree_image = lib.free_image\\nfree_image.argtypes = [IMAGE]\\n\\nletterbox_image = lib.letterbox_image\\nletterbox_image.argtypes = [IMAGE, c_int, c_int]\\nletterbox_image.restype = IMAGE\\n\\n_load_meta = lib.get_metadata\\nlib.get_metadata.argtypes = [c_char_p]\\nlib.get_metadata.restype = METADATA\\n\\nload_image = lib.load_image_color\\nload_image.argtypes = [c_char_p, c_int, c_int]\\nload_image.restype = IMAGE\\n\\nrgbgr_image = lib.rgbgr_image\\nrgbgr_image.argtypes = [IMAGE]\\n\\npredict_image = lib.network_predict_image\\npredict_image.argtypes = [c_void_p, IMAGE]\\npredict_image.restype = POINTER(c_float)\\n\\ndef classify(net, meta, im):\\n    out = predict_image(net, im)\\n    res = []\\n    for i in range(meta.classes):\\n        res.append((meta.names[i], out[i]))\\n    res = sorted(res, key=lambda x: -x[1])\\n    return res\\n\\ndef load_net(cfg_path, weights_path, clear=0):\\n    return _load_net(cfg_path.encode('ascii'), weights_path.encode('ascii'), clear)\\ndef load_meta(cfg_path):\\n    return _load_meta(cfg_path.encode('ascii'))\\n\\ndef _detect(net, meta, im, thresh=.5, hier_thresh=.5, nms=.45):\\n    num = c_int(0)\\n    pnum = pointer(num)\\n    predict_image(net, im)\\n    dets = get_network_boxes(net, im.w, im.h, thresh, hier_thresh, None, 0, pnum)\\n    num = pnum[0]\\n    if (nms): do_nms_obj(dets, num, meta.classes, nms);\\n\\n    res = []\\n    for j in range(num):\\n        for i in range(meta.classes):\\n            if dets[j].prob[i] > 0:\\n                b = dets[j].bbox\\n                res.append((meta.names[i], dets[j].prob[i], (b.x, b.y, b.w, b.h)))\\n    res = sorted(res, key=lambda x: -x[1])\\n\\n    free_detections(dets, num)\\n    return res\\n\\ndef detect(net, meta, image_path, thresh=.5, hier_thresh=.5, nms=.45):\\n    im = load_image(image_path, 0, 0)\\n    res = _detect(net, meta, im, thresh, hier_thresh, nms)\\n    free_image(im)\\n\\n    return res\\n\\ndef array_to_image(arr):\\n    arr = arr.transpose(2,0,1)\\n    c = arr.shape[0]\\n    h = arr.shape[1]\\n    w = arr.shape[2]\\n    arr = (arr/255.0).flatten()\\n    data = c_array(c_float, arr)\\n    im = IMAGE(w,h,c,data)\\n    return im\\n\\ndef detect_cv(net, meta, np_image, thresh=.5, hier_thresh=.5, nms=.45):\\n    im = array_to_image(np_image)\\n    rgbgr_image(im)\\n\\n    return _detect(net, meta, im, thresh, hier_thresh, nms)\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"darknet.py OpenCV darknet.pyにコードが古くなってるっぽい examples/detector-scipy-opencv.py のOpenCV部を取り込み、Python 3用に","tableOfContents":{"items":[{"url":"#darknetpy-opencv","title":"darknet.py OpenCV"}]},"frontmatter":{"title":"darknet.py OpenCV","date":"2019-10-30T14:03:48.000Z","updated":null,"noindex":null,"channel":"技術ノート","category":"Python","tags":["Python","機械学習"]}}},"pageContext":{"id":"ac0e6395-e983-5d79-9575-97cba95efbb9"}},
    "staticQueryHashes": []}